# jest 单元测试

定义: 是指对软件中的最小可测试单元进行检查和验证

优势: 从长期来看，可以提高代码质量，减少维护成本，降低重构难度
缺点: 从短期来看，加大了工作量，对于进度紧张的项目中的开发人员来说，可能会成为不少的负担

三连问: 为什么要写单元测试/何时写/测试颗粒度为多少

颗粒度

  1. 逻辑复杂的
  2. 容易出错的
  3. 不易理解的 即使是自己写的过段时也会遗忘,有助于理解代码的功能和需求
  4. 公共代码 工具类
  5. 核心业务代码 产品里最核心/最有业务价值的代码应该有更高的单元测试覆盖率

何时写

  1. TDD(敏捷开发中的一项核心实践和技术，也是一种设计方法论。) 在具体实现代码之前
  2. 与具体实现代码同步开发 (先写少量功能代码,紧接着写单元测试,基本上功能开发完,单元测试也完成了)
  3. 写完功能代码后再写单元测试 (实际上‘事后’编写的单元测试颗粒度都比较大,对比同样的功能代码,采取前两种方案可能有10个小的单元测试来覆盖,每个单元测试比较简单易懂,可维护性/可读性都比较好--重构时单测改动不大 而第三种方案 可能会写一个大的单元测试, 这个单侧的逻辑比较复杂, 因为它要测的东西很多,可读性可维护性就比较差)

为什么要写单元测试

  1. 自己的代码有信心 (修改的代码依然能够通过单测, 起码说明我们修改的代码没有破坏程序的正确性 )
  2. 为代码重构做准备 (看到代码很差劲,想重构,但有担心重构之后出问题,咋办? 如果有单元测试之后情况就不一样了,重构完代码，跑一遍单元测试，如果单元测试都通过，基本上可以保证我们的重构没有破坏原来代码逻辑的正确性。不过前提是之前的写的单元测试质量很好，覆盖率很高。当然这仅限于小范围的重构，比如重构一个类或者函数的实现，但对于大刀阔斧的重构（比如单体重构成微服务，面向库表模式重构成DDD），就不适用，那个时候要重写单元测试了)
  3. 通过单元测试快速熟悉代码 (单元测试不仅起到了测试的作用，还是一种很好的“文档”，通过单元测试，我们不需要深入的阅读代码，便能知道这段代码做什么工作，有哪些特殊情况需要考虑，包含哪些业务)



## jest配置文件 jest.config.js

### moduleFileExtensions

测试文件的类型

默认值 ["js", "json", "jsx", "ts", "tsx", "node"]

### transform

转换器 (类似与 webpack loader)

默认值 {"^.+\\.[jt]sx?$": "babel-jest"}

### transformIgnorePatterns

默认值 ["/node_modules/", "\\.pnp\\.[^\\\/]+$"]

### moduleNameMapper

别名 (类似与 webpack alias)

### testMatch

设置识别哪些文件是测试文件（glob形式）与testRegex互斥，不能同时写

默认值 [ "**/__tests__/**/*.[jt]s?(x)", "**/?(*.)+(spec|test).[jt]s?(x)" ]

### testRegex

设置识别哪些文件是测试文件（正则形式），与testMatch互斥，不能同时写

默认值 (/__tests__/.*|(\\.|/)(test|spec))\\.[jt]sx?$

### testURL

设置jsdom环境的URL

默认值 http://localhost

### watchPlugins

定义监视模式菜单提示符 一般用在开发针对工作流程定制的交互式体验

### globals

一组全局变量，需要在所有测试环境中使用

## 常用的一些测试

### vue/test-utils

  vue官方的单元测试库


### jest



## vue js

## vue TS

### 安装

[官方安装](https://vue-test-utils.vuejs.org/zh/installation/testing-single-file-components-with-jest.html)

```bash

npm install --save-dev jest @vue/test-utils vue-jest ts-jest

```


## node

## webpack

## mongodb
